#!/bin/bash

set -euo pipefail # Exit on error, unset var, and pipe failure

# --- Configuration ---
DEFAULT_DELETE_OPTION="-d" # Default is a "safe" delete
FORCE_DELETE_OPTION="-D"   # Option for forced delete

# --- Variables ---
DELETE_OPTION="$DEFAULT_DELETE_OPTION"
SHOW_HELP=false

# --- Functions ---

# Function to display help message
show_help() {
  cat << EOF
Usage: $(basename "$0") [options]

Deletes local Git branches whose remote tracking branch has been deleted (marked as 'gone'),
excluding the currently checked-out branch.
This script automatically runs 'git fetch --prune' before checking for branches
to ensure the local view of remote branches is up to date.

Options:
  --force     Force delete branches. This uses 'git branch -D' instead of 'git branch -d'.
              Use with caution, as this will delete branches even if they are
              not fully merged. (The current branch will still be skipped).
  -h, --help  Display this help message and exit.
EOF
}

# --- Argument Parsing ---
for arg in "$@"; do
  case "$arg" in
    -h|--help)
      SHOW_HELP=true
      ;;
    --force)
      DELETE_OPTION="$FORCE_DELETE_OPTION"
      ;;
    *)
      echo "Error: Unrecognized option or argument: '$arg'" >&2
      echo >&2
      show_help
      exit 1
      ;;
  esac
done

if [ "$SHOW_HELP" = true ]; then
  show_help
  exit 0
fi

# --- Main Script Logic ---

current_branch_name=""
current_branch_name_temp=$(git symbolic-ref --short HEAD 2>/dev/null || true)
if [ "$current_branch_name_temp" != "HEAD" ] && [ -n "$current_branch_name_temp" ]; then
    current_branch_name="$current_branch_name_temp"
fi

if [ -z "$current_branch_name" ]; then
    echo "Info: Currently in a detached HEAD state or current branch could not be determined. No branch will be skipped based on 'current branch' status."
fi

echo "Updating remote-tracking branches with 'git fetch --prune'..."
if ! git fetch --prune; then
  echo "Error: 'git fetch --prune' failed. Please check your Git setup and remote connection." >&2
  exit 1
fi
echo

echo "Identifying local branches whose upstream remote has been deleted..."
all_gone_branch_candidates=$(git branch -vv | (grep ': gone]' || true) | awk '{if ($1 == "*") {print $2} else {print $1}}')

final_branches_to_delete_list=""
current_branch_was_candidate_and_skipped=false

if [ -n "$all_gone_branch_candidates" ]; then
  while IFS= read -r branch_name; do
    if [ -n "$current_branch_name" ] && [ "$branch_name" == "$current_branch_name" ]; then
      current_branch_was_candidate_and_skipped=true
    else
      if [ -z "$final_branches_to_delete_list" ]; then
        final_branches_to_delete_list="$branch_name"
      else
        final_branches_to_delete_list="${final_branches_to_delete_list}
${branch_name}"
      fi
    fi
  done <<< "$all_gone_branch_candidates"
fi

if [ "$current_branch_was_candidate_and_skipped" = true ]; then
  echo
  echo "Info: Deletion of '$current_branch_name' will be skipped since it is the current branch."
fi

gone_branches="$final_branches_to_delete_list"

if [ -z "$gone_branches" ]; then
  echo
  if [ "$current_branch_was_candidate_and_skipped" = true ]; then
    echo "No other local branches (besides the skipped current branch) were found for deletion."
  else
    echo "No local branches found that are tracking a remote branch which has been deleted."
  fi
  exit 0
fi

echo
echo "The following local branches are targeted for deletion using the '${DELETE_OPTION}' option:"
while IFS= read -r branch_to_display; do
  if [ -n "$branch_to_display" ]; then
    echo "  - $branch_to_display"
  fi
done <<< "$gone_branches"
echo

read -r -p "Are you sure you want to delete these branches? (yes/NO): " confirmation

if [[ "$(echo "$confirmation" | tr '[:upper:]' '[:lower:]')" != "yes" ]]; then
  echo "Aborted by user. No branches were deleted."
  exit 0
fi

echo "Deleting branches..."
echo "$gone_branches" | xargs -r -- git branch "$DELETE_OPTION"

echo "Selected local branches have been processed for deletion."
